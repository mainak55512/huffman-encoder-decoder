Time: 2:16:09 pm
Date: 12/2/2025
I want to get my hands dirty with Zig. This language facinates me. Currently I am using Golang for my side projects, honestly go lang is fav, it is almost a high-level language and I really enjoy working in it. I tried Rust as well, which is good but the borrow checker gives me hard time. I want to use a low level language which is easy as well. I considered three languages -> Zig, Odin & Jai. I am a bit skeptical abaout the development of Jai. Odin is good as I have seen some reviewes, but Zig is the one most people are talking about, so I decided to go with Zig. I will try to build something as I go.
  
Time: 9:23:26 pm
Date: 14/2/2025
I got a new project idea that I want to execute in Zig. So I was asking Perplexity to give me some project ideas where I will be doing some system programming and will dig deep into manual memory management and it came up with file compression algorithm implementation!   So I started searching some online resources and found one article which explains how some of the comparison algorithms work, so I guess I will be following that to implement mine and learn concepts of Zig. Yesterday I implemented the Map and Filter functions in zig, which I did earlier with Go as well. So I found that it is much difficult to implement the same algo in a manually memory managed language than an automatic memory managed language. Where in go, I just have to pass the data to the map or filter function and after execution all data are taken care by the garbage collector, but in zig, I had to put the freeing statements in proper places wheather in map or filter functions or in the main method to remove the garbage.  I am hoping that, learning a manually memory managed language will help me to better understand the programming as a whole.
  
Time: 8:06:04 pm
Date: 15/2/2025
Started working on Huffman encoder/decoder in Zig. As of now, I am only reading one text file and counting occurance of each letter in it. I am using zig's autohashmap to store the letter as the key and number of occurance as the value. Next step is to create a binary tree from the hashmap to generate the prefixes.  I have found some doc (https://opendsa-server.cs.vt.edu/ODSA/Books/CS3/html/Huffman.html) which explains how to create the binary tree but I am having some hard time to figure that out. Hopefully I can implement it soon.
  
Time: 9:26:59 pm
Date: 1/3/2025
I am still working on huffman encoder and decoder. It is now able to encode the content and save it in a file though a sophesticated process has not been established yet.  Storing the huffman tree was bit of a challenge. I flattened the tree in a string containing 0's, 1's and the characters like 001A1B1C etc. where 0 is an internal node and 1 is leafnode containing the actual element. So I stored 0's and 1's as single bit and converted other characters to a 7bit format. So for 001A1B1C it earlier took 8x7 = 56 bits = 7 bytes, Now, it will take 1+1+1+7+1+7+1+7 = 26bits ~ 4 bytes.  I also created the method for rebuilding the huffman tree from the flattened string, hopefully that is working as I can not tell right now until and unless the decoder is implemented.
  
